// MetaReal Programming Language version 1.0.0

#include <ir/gen.h>
#include <ir/value.h>
#include <stdlib.h>
#include <string.h>
#include <crash.h>

ir_t ir_init();

data_t data_init();

block_t visit_node(gres_p res, node_t node, stack_t stack, heap_t heap, context_t context);

block_t visit_int(node_t node, stack_t stack);
block_t visit_float(node_t node, stack_t stack);
block_t visit_bool(node_t node);
block_t visit_str(node_t node, stack_t stack, heap_t heap);
block_t visit_list(gres_p res, node_t node, stack_t stack, heap_t heap, context_t context);
block_t visit_tuple(gres_p res, node_t node, stack_t stack, heap_t heap, context_t context);
block_t visit_dict(gres_p res, node_t node, stack_t stack, heap_t heap, context_t context);
block_t visit_binary_operation(gres_p res, node_t node, stack_t stack, heap_t heap, context_t context);

gres_t gen(node_p nodes, stack_t stack, heap_t heap, context_t context)
{
    gres_t res;
    res._has_error = 0;

    res._ir = ir_init();
    res._data = data_init();

    uint64 alloc = IR_MAIN_SIZE;

    while (nodes->_type != EOF_N)
    {
        block_t block = visit_node(&res, *nodes++, stack, heap, context);

        if (res._has_error)
        {
            free(nodes);
            ir_free(res._ir);
            return res;
        }

        if (res._ir._msize == alloc)
        {
            res._ir._main = realloc(res._ir._main, (alloc += IR_MAIN_SIZE) * sizeof(block_t));
            if (!res._ir._main)
                alloc_error(alloc * sizeof(block_t));
        }

        res._ir._main[res._ir._msize++] = block;
    }

    if (res._ir._msize != alloc)
    {
        res._ir._main = realloc(res._ir._main, res._ir._msize * sizeof(block_t));
        if (!res._ir._main)
            alloc_error(res._ir._msize * sizeof(block_t));
    }

    free(nodes);
    return res;
}

void gres_fail(gres_p res, runtime_t error)
{
    res->_error = error;
    res->_has_error = 1;
}

void ir_print(data_p data, ir_t ir)
{
    fputs("@ Generated by MetaReal version 1.0.0\n\n", STDOUT);

    if (ir._isize)
    {
        uint64 i;
        for (i = 0; i < ir._isize; i++)
            fprintf(STDOUT, "#inc <%s>\n", ir._incs[i]);

        fputc('\n', STDOUT);
    }

    if (ir._dsize)
    {
        uint64 i;
        for (i = 0; i < ir._dsize; i++)
        {
            block_print(data, &ir._defs[i], ";\n");
            fputc('\n', STDOUT);
        }
    }

    fputs("&main($argc |int, $argv |lst) |int\n{\n", STDOUT);

    if (ir._msize)
    {
        uint64 i;
        for (i = 0; i < ir._msize; i++)
        {
            if (!OPT_LVL)
            {
                if (IS_USEFUL(ir._main[i]._properties))
                {
                    block_print(data, &ir._main[i], ";\n");
                    fputc('\n', STDOUT);
                }

                continue;
            }

            block_print(data, &ir._main[i], ";\n");
            fputc('\n', STDOUT);
        }
    }

    fputs("~ret (0);\n}\n", STDOUT);

    if (ir._fsize)
    {
        fputc('\n', STDOUT);

        uint64 i;
        for (i = 0; i < ir._fsize; i++)
        {
            block_print(data, &ir._funcs[i], ";\n");
            fputc('\n', STDOUT);
        }
    }
}

void ir_free(ir_t ir)
{
    if (ir._isize)
        free(ir._incs);

    if (ir._dsize)
        free(ir._defs);

    if (ir._msize)
        free(ir._main);

    if (ir._fsize)
        free(ir._funcs);
}

ir_t ir_init()
{
    ir_t ir;

    ir._isize = 0;
    ir._dsize = 0;
    ir._msize = 0;
    ir._fsize = 0;

    ir._main = malloc(IR_MAIN_SIZE * sizeof(block_t));
    if (!ir._main)
        alloc_error(IR_MAIN_SIZE * sizeof(block_t));

    return ir;
}

data_t data_init()
{
    data_t data;

    data._int_count = 0;
    data._float_count = 0;
    data._bool_count = 0;
    data._str_count = 0;
    data._list_count = 0;
    data._tuple_count = 0;
    data._dict_count = 0;

    return data;
}

block_t visit_node(gres_p res, node_t node, stack_t stack, heap_t heap, context_t context)
{
    switch (node._type)
    {
    case INT_N:
        return visit_int(node, stack);
    case FLOAT_N:
        return visit_float(node, stack);
    case BOOL_N:
        return visit_bool(node);
    case STR_N:
        return visit_str(node, stack, heap);
    case LIST_N:
        return visit_list(res, node, stack, heap, context);
    case TUPLE_N:
        return visit_tuple(res, node, stack, heap, context);
    case DICT_N:
        return visit_dict(res, node, stack, heap, context);
    case BINARY_OPERATION_N:
        return visit_binary_operation(res, node, stack, heap, context);
    }
}

block_t visit_int(node_t node, stack_t stack)
{
    int_n node_ = node._node;

    mint_t value;
    set_mint_str(value, node_->_value);

    int_i block = int_i_set(stack, value);

    return block_set1(INT_I, block, INT_V, SET_PROPERTIES(0, 0, 0));
}

block_t visit_float(node_t node, stack_t stack)
{
    float_n node_ = node._node;

    mfloat_t value;
    set_mfloat_str(value, node_->_value);

    float_i block = float_i_set(stack, value);

    return block_set1(FLOAT_I, block, FLOAT_V, SET_PROPERTIES(0, 0, 0));
}

block_t visit_bool(node_t node)
{
    bool_n node_ = node._node;

    if (node_->_stat)
        return block_set2(BOOL_I, BOOL_V, SET_PROPERTIES(0, 0, 1));
    return block_set2(BOOL_I, BOOL_V, SET_PROPERTIES(0, 0, 0));
}

block_t visit_str(node_t node, stack_t stack, heap_t heap)
{
    if (!node._node)
        return block_set2(STR_I, STR_V, SET_PROPERTIES(0, 0, 0));

    str_n node_ = node._node;

    mstr_t value;
    set_mstr(heap, value, node_->_value, node_->_len);

    str_i block = str_i_set(stack, value);

    return block_set1(STR_I, block, STR_V, SET_PROPERTIES(0, 0, 0));
}

block_t visit_list(gres_p res, node_t node, stack_t stack, heap_t heap, context_t context)
{
    if (!node._node)
        return block_set2(LIST_I, LIST_V, SET_PROPERTIES(0, 0, 0));

    list_n node_ = node._node;

    block_p elements = heap_alloc(heap, node_->_size * sizeof(block_t));

    uint8 is_useful = 0;
    uint64 i;
    for (i = 0; i < node_->_size; i++)
    {
        block_t element = visit_node(res, node_->_elements[i], stack, heap, context);

        if (res->_has_error)
            return element;

        elements[i] = element;

        if (IS_USEFUL(element._properties))
            is_useful = 1;
    }

    mlist_t value;
    set_mlist(value, elements, node_->_size);

    list_i block = list_i_set(stack, value);

    if (is_useful)
        return block_set1(LIST_I, block, LIST_V, SET_PROPERTIES(1, 1, 0));
    return block_set1(LIST_I, block, LIST_V, SET_PROPERTIES(0, 1, 0));
}

block_t visit_tuple(gres_p res, node_t node, stack_t stack, heap_t heap, context_t context)
{
    if (!node._node)
        return block_set2(TUPLE_I, TUPLE_V, SET_PROPERTIES(0, 0, 0));

    tuple_n node_ = node._node;

    block_p elements = heap_alloc(heap, node_->_size * sizeof(block_t));

    uint8 is_useful = 0;
    uint64 i;
    for (i = 0; i < node_->_size; i++)
    {
        block_t element = visit_node(res, node_->_elements[i], stack, heap, context);

        if (res->_has_error)
            return element;

        elements[i] = element;

        if (IS_USEFUL(element._properties))
            is_useful = 1;
    }

    mtuple_t value;
    set_mtuple(value, elements, node_->_size);

    tuple_i block = tuple_i_set(stack, value);

    if (is_useful)
        return block_set1(TUPLE_I, block, TUPLE_V, SET_PROPERTIES(1, 1, 0));
    return block_set1(TUPLE_I, block, TUPLE_V, SET_PROPERTIES(0, 1, 0));
}

block_t visit_dict(gres_p res, node_t node, stack_t stack, heap_t heap, context_t context)
{
}

block_t visit_binary_operation(gres_p res, node_t node, stack_t stack, heap_t heap, context_t context)
{
    binary_operation_n node_ = node._node;

    block_t op1 = visit_node(res, node_->_op1, stack, heap, context);

    if (res->_has_error)
        return op1;

    block_t op2 = visit_node(res, node_->_op2, stack, heap, context);

    if (res->_has_error)
        return op2;

    switch (node_->_operator)
    {
    case ADD_T:
        return value_add(res, op1, op2, stack, heap, context, node._poss, node._pose);
    }
}
